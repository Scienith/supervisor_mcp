{
  "identifier": "contractTestSkeleton",
  "name": "契约测试骨架",
  "stage": "implementing",
  "description": "把行为约束写成测试，用于未来FAKE/REAL的一致性验证",
  "outputs": [
    {
      "name": "契约测试文件",
      "description": "每个契约单元的行为测试用例",
      "path": "tests/contracts/test_<contract>_*.py",
      "type": "PATTERN",
      "template_filename": null,
      "template_content": ""
    },
    {
      "name": "测试基类",
      "description": "契约测试的通用基类和工具",
      "path": "tests/contracts/base.py",
      "type": "FILE",
      "template_filename": "contract_test_base.py",
      "template_content": "\"\"\"\n契约测试基类和工具\n\n提供契约测试的通用基础设施，包括成熟度检查、测试工具等\n\"\"\"\n\nimport pytest\nfrom abc import ABC, abstractmethod\nfrom typing import Any, Dict, List, Optional, Protocol, TypeVar, Generic\nfrom enum import Enum\n\n\nclass MaturityLevel(Enum):\n    \"\"\"成熟度级别枚举\"\"\"\n    STUB = \"STUB\"\n    FAKE = \"FAKE\" \n    REAL = \"REAL\"\n\n\nclass ContractUnit(Protocol):\n    \"\"\"契约单元协议定义\"\"\"\n    __impl__: Dict[str, Any]  # 包含maturity和notes\n\n\nT = TypeVar('T', bound=ContractUnit)\n\n\nclass ContractTestBase(ABC, Generic[T]):\n    \"\"\"\n    契约测试基类\n    \n    为所有契约单元提供统一的测试基础设施\n    \"\"\"\n    \n    @property\n    @abstractmethod\n    def contract_unit(self) -> T:\n        \"\"\"返回被测试的契约单元实例\"\"\"\n        pass\n    \n    @property\n    def contract_maturity(self) -> MaturityLevel:\n        \"\"\"获取契约单元的当前成熟度\"\"\"\n        impl_info = getattr(self.contract_unit, '__impl__', {})\n        maturity_str = impl_info.get('maturity', 'STUB')\n        return MaturityLevel(maturity_str)\n    \n    @property\n    def contract_notes(self) -> str:\n        \"\"\"获取契约单元的实现备注\"\"\"\n        impl_info = getattr(self.contract_unit, '__impl__', {})\n        return impl_info.get('notes', '')\n    \n    def skip_if_stub(self, reason: str = \"Contract unit is still STUB\"):\n        \"\"\"如果契约单元是STUB状态则跳过测试\"\"\"\n        if self.contract_maturity == MaturityLevel.STUB:\n            pytest.skip(reason)\n    \n    def xfail_if_stub(self, reason: str = \"Contract unit is still STUB\"):\n        \"\"\"如果契约单元是STUB状态则标记为预期失败\"\"\"\n        if self.contract_maturity == MaturityLevel.STUB:\n            pytest.xfail(reason)\n    \n    def require_maturity(self, min_level: MaturityLevel):\n        \"\"\"要求契约单元达到最低成熟度级别\"\"\"\n        maturity_order = {\n            MaturityLevel.STUB: 0,\n            MaturityLevel.FAKE: 1, \n            MaturityLevel.REAL: 2\n        }\n        \n        current_level = maturity_order[self.contract_maturity]\n        required_level = maturity_order[min_level]\n        \n        if current_level < required_level:\n            pytest.skip(f\"Contract unit maturity {self.contract_maturity.value} < required {min_level.value}\")\n\n\nclass ContractTestSuite(ContractTestBase[T]):\n    \"\"\"\n    标准契约测试套件\n    \n    提供常见的测试方法模板\n    \"\"\"\n    \n    def test_basic_functionality(self):\n        \"\"\"测试基本功能 - 正常路径\"\"\"\n        self.skip_if_stub()\n        # 子类实现具体的基本功能测试\n        self._test_basic_functionality()\n    \n    def test_error_handling(self):\n        \"\"\"测试错误处理\"\"\"\n        self.skip_if_stub()\n        # 子类实现具体的错误处理测试\n        self._test_error_handling()\n    \n    def test_boundary_conditions(self):\n        \"\"\"测试边界条件\"\"\"\n        self.skip_if_stub()\n        # 子类实现具体的边界条件测试\n        self._test_boundary_conditions()\n    \n    def test_invariants(self):\n        \"\"\"测试不变量\"\"\"\n        self.skip_if_stub()\n        # 子类实现具体的不变量测试\n        self._test_invariants()\n    \n    def test_round_trip(self):\n        \"\"\"测试往返一致性\"\"\"\n        self.skip_if_stub()\n        # 子类实现具体的往返测试\n        self._test_round_trip()\n    \n    # 抽象方法，子类必须实现\n    @abstractmethod\n    def _test_basic_functionality(self):\n        \"\"\"实现基本功能测试逻辑\"\"\"\n        pass\n    \n    @abstractmethod\n    def _test_error_handling(self):\n        \"\"\"实现错误处理测试逻辑\"\"\"\n        pass\n    \n    @abstractmethod\n    def _test_boundary_conditions(self):\n        \"\"\"实现边界条件测试逻辑\"\"\"\n        pass\n    \n    @abstractmethod\n    def _test_invariants(self):\n        \"\"\"实现不变量测试逻辑\"\"\"\n        pass\n    \n    def _test_round_trip(self):\n        \"\"\"实现往返测试逻辑（可选实现）\"\"\"\n        pass\n\n\n# 测试数据生成工具\nclass TestDataBuilder:\n    \"\"\"测试数据构建器\"\"\"\n    \n    @staticmethod\n    def valid_input_samples() -> List[Dict[str, Any]]:\n        \"\"\"生成有效输入样本\"\"\"\n        return [\n            # 子类可以重写这个方法提供具体的测试数据\n        ]\n    \n    @staticmethod\n    def invalid_input_samples() -> List[Dict[str, Any]]:\n        \"\"\"生成无效输入样本\"\"\"\n        return [\n            # 子类可以重写这个方法提供具体的测试数据\n        ]\n    \n    @staticmethod\n    def boundary_input_samples() -> List[Dict[str, Any]]:\n        \"\"\"生成边界值输入样本\"\"\"\n        return [\n            # 子类可以重写这个方法提供具体的测试数据\n        ]\n\n\n# 断言工具\nclass ContractAssertions:\n    \"\"\"契约测试专用断言工具\"\"\"\n    \n    @staticmethod\n    def assert_error_type(func, expected_error_type, *args, **kwargs):\n        \"\"\"断言函数抛出指定类型的异常\"\"\"\n        with pytest.raises(expected_error_type):\n            func(*args, **kwargs)\n    \n    @staticmethod\n    def assert_invariant(condition: bool, message: str):\n        \"\"\"断言不变量条件\"\"\"\n        assert condition, f\"Invariant violation: {message}\"\n    \n    @staticmethod\n    def assert_output_shape(output: Any, expected_type: type, expected_fields: Optional[List[str]] = None):\n        \"\"\"断言输出的形状和类型\"\"\"\n        assert isinstance(output, expected_type), f\"Expected {expected_type}, got {type(output)}\"\n        \n        if expected_fields and hasattr(output, '__dict__'):\n            for field in expected_fields:\n                assert hasattr(output, field), f\"Missing expected field: {field}\"\n    \n    @staticmethod\n    def assert_round_trip_consistency(original: Any, processed: Any, equality_func=None):\n        \"\"\"断言往返一致性\"\"\"\n        if equality_func:\n            assert equality_func(original, processed), \"Round-trip consistency failed\"\n        else:\n            assert original == processed, \"Round-trip consistency failed\"\n\n\n# 性能测试工具\nclass PerformanceAssertions:\n    \"\"\"性能相关的断言工具\"\"\"\n    \n    @staticmethod\n    def assert_execution_time(func, max_seconds: float, *args, **kwargs):\n        \"\"\"断言函数执行时间不超过指定秒数\"\"\"\n        import time\n        start_time = time.time()\n        result = func(*args, **kwargs)\n        execution_time = time.time() - start_time\n        assert execution_time <= max_seconds, f\"Execution took {execution_time:.3f}s, expected <= {max_seconds}s\"\n        return result\n    \n    @staticmethod\n    def assert_memory_usage(func, max_mb: float, *args, **kwargs):\n        \"\"\"断言函数内存使用不超过指定MB（需要安装memory_profiler）\"\"\"\n        try:\n            from memory_profiler import profile\n            # 这里需要具体的内存测量实现\n            pass\n        except ImportError:\n            pytest.skip(\"memory_profiler not installed\")\n\n\n# 示例契约测试类模板\nclass ExampleContractTest(ContractTestSuite):\n    \"\"\"\n    示例契约测试类\n    \n    展示如何继承ContractTestSuite实现具体的契约测试\n    \"\"\"\n    \n    @property\n    def contract_unit(self):\n        # 返回被测试的契约单元实例\n        # return MyContractUnit()\n        raise NotImplementedError(\"请实现contract_unit属性\")\n    \n    def _test_basic_functionality(self):\n        \"\"\"实现基本功能测试\"\"\"\n        # 示例测试逻辑\n        result = self.contract_unit.some_method(\"test_input\")\n        assert result is not None\n        ContractAssertions.assert_output_shape(result, dict, [\"expected_field\"])\n    \n    def _test_error_handling(self):\n        \"\"\"实现错误处理测试\"\"\"\n        # 测试各种错误情况\n        ContractAssertions.assert_error_type(\n            self.contract_unit.some_method, \n            ValueError, \n            \"invalid_input\"\n        )\n    \n    def _test_boundary_conditions(self):\n        \"\"\"实现边界条件测试\"\"\"\n        # 测试边界值\n        boundary_inputs = TestDataBuilder.boundary_input_samples()\n        for input_data in boundary_inputs:\n            result = self.contract_unit.some_method(input_data)\n            assert result is not None\n    \n    def _test_invariants(self):\n        \"\"\"实现不变量测试\"\"\"\n        # 验证业务不变量\n        result = self.contract_unit.some_method(\"test\")\n        ContractAssertions.assert_invariant(\n            len(result) > 0,\n            \"Result should never be empty\"\n        )"
    },
    {
      "name": "测试配置",
      "description": "契约测试的配置和标记",
      "path": "tests/contracts/conftest.py",
      "type": "FILE",
      "template_filename": "conftest.py",
      "template_content": "\"\"\"\n契约测试配置文件\n\n提供契约测试的全局配置、fixture和工具\n\"\"\"\n\nimport pytest\nfrom typing import Dict, Any, List\nfrom unittest.mock import Mock, MagicMock\n\n\n# 测试标记配置\npytest_plugins = []\n\n\ndef pytest_configure(config):\n    \"\"\"pytest配置钩子\"\"\"\n    # 注册自定义标记\n    config.addinivalue_line(\n        \"markers\", \"contract: 契约测试，验证FAKE/REAL实现的行为一致性\"\n    )\n    config.addinivalue_line(\n        \"markers\", \"maturity_stub: 针对STUB状态的测试（通常skip）\"\n    )\n    config.addinivalue_line(\n        \"markers\", \"maturity_fake: 针对FAKE状态的测试\"\n    )\n    config.addinivalue_line(\n        \"markers\", \"maturity_real: 针对REAL状态的测试\"\n    )\n    config.addinivalue_line(\n        \"markers\", \"round_trip: 往返一致性测试\"\n    )\n    config.addinivalue_line(\n        \"markers\", \"invariant: 不变量测试\"\n    )\n    config.addinivalue_line(\n        \"markers\", \"boundary: 边界条件测试\"\n    )\n    config.addinivalue_line(\n        \"markers\", \"error_handling: 错误处理测试\"\n    )\n\n\ndef pytest_collection_modifyitems(config, items):\n    \"\"\"修改测试收集结果\"\"\"\n    # 为契约测试目录下的所有测试自动添加contract标记\n    for item in items:\n        if \"contracts\" in str(item.fspath):\n            item.add_marker(pytest.mark.contract)\n\n\n# 通用fixture\n@pytest.fixture\ndef valid_test_data():\n    \"\"\"提供有效的测试数据\"\"\"\n    return {\n        \"string_input\": \"test_string\",\n        \"integer_input\": 42,\n        \"list_input\": [1, 2, 3],\n        \"dict_input\": {\"key\": \"value\"},\n        \"boolean_input\": True,\n        \"optional_input\": None\n    }\n\n\n@pytest.fixture\ndef invalid_test_data():\n    \"\"\"提供无效的测试数据\"\"\"\n    return {\n        \"empty_string\": \"\",\n        \"negative_integer\": -1,\n        \"empty_list\": [],\n        \"empty_dict\": {},\n        \"null_value\": None,\n        \"wrong_type\": \"should_be_integer\"\n    }\n\n\n@pytest.fixture\ndef boundary_test_data():\n    \"\"\"提供边界值测试数据\"\"\"\n    return {\n        \"min_integer\": 0,\n        \"max_integer\": 2**31 - 1,\n        \"min_string\": \"a\",\n        \"max_string\": \"x\" * 1000,\n        \"single_item_list\": [1],\n        \"large_list\": list(range(1000))\n    }\n\n\n@pytest.fixture\ndef mock_external_dependencies():\n    \"\"\"模拟外部依赖\"\"\"\n    return {\n        \"database\": Mock(),\n        \"api_client\": Mock(),\n        \"cache\": Mock(),\n        \"logger\": Mock(),\n        \"config\": Mock()\n    }\n\n\n@pytest.fixture\ndef error_scenarios():\n    \"\"\"错误场景数据\"\"\"\n    return {\n        \"validation_error\": {\n            \"input\": {\"invalid\": \"data\"},\n            \"expected_error\": ValueError,\n            \"error_message\": \"Invalid input data\"\n        },\n        \"not_found_error\": {\n            \"input\": {\"id\": \"non_existent\"},\n            \"expected_error\": KeyError,\n            \"error_message\": \"Resource not found\"\n        },\n        \"permission_error\": {\n            \"input\": {\"user\": \"unauthorized\"},\n            \"expected_error\": PermissionError,\n            \"error_message\": \"Access denied\"\n        }\n    }\n\n\n@pytest.fixture\ndef performance_constraints():\n    \"\"\"性能约束配置\"\"\"\n    return {\n        \"max_execution_time\": 1.0,  # 秒\n        \"max_memory_usage\": 100,    # MB\n        \"max_api_calls\": 10,        # 最大API调用次数\n        \"max_db_queries\": 5         # 最大数据库查询次数\n    }\n\n\n# 成熟度相关的fixture\n@pytest.fixture\ndef maturity_checker():\n    \"\"\"成熟度检查器\"\"\"\n    def check_maturity(contract_unit, expected_maturity=None):\n        \"\"\"检查契约单元的成熟度\"\"\"\n        impl_info = getattr(contract_unit, '__impl__', {})\n        actual_maturity = impl_info.get('maturity', 'STUB')\n        \n        if expected_maturity and actual_maturity != expected_maturity:\n            pytest.skip(f\"Contract maturity {actual_maturity} != expected {expected_maturity}\")\n        \n        return actual_maturity\n    \n    return check_maturity\n\n\n@pytest.fixture\ndef contract_inspector():\n    \"\"\"契约单元检查器\"\"\"\n    def inspect_contract(contract_unit):\n        \"\"\"检查契约单元的基本信息\"\"\"\n        impl_info = getattr(contract_unit, '__impl__', {})\n        \n        return {\n            \"maturity\": impl_info.get('maturity', 'UNKNOWN'),\n            \"notes\": impl_info.get('notes', ''),\n            \"has_docstring\": bool(contract_unit.__doc__),\n            \"method_count\": len([attr for attr in dir(contract_unit) \n                               if callable(getattr(contract_unit, attr)) \n                               and not attr.startswith('_')]),\n            \"class_name\": contract_unit.__class__.__name__\n        }\n    \n    return inspect_contract\n\n\n# 测试数据生成器\n@pytest.fixture\ndef test_data_generator():\n    \"\"\"测试数据生成器\"\"\"\n    class TestDataGenerator:\n        @staticmethod\n        def generate_valid_samples(count: int = 5) -> List[Dict[str, Any]]:\n            \"\"\"生成有效样本数据\"\"\"\n            return [\n                {\"id\": i, \"name\": f\"test_{i}\", \"active\": True}\n                for i in range(count)\n            ]\n        \n        @staticmethod\n        def generate_invalid_samples() -> List[Dict[str, Any]]:\n            \"\"\"生成无效样本数据\"\"\"\n            return [\n                {},  # 空对象\n                {\"id\": None},  # 缺少必需字段\n                {\"id\": -1, \"name\": \"\"},  # 无效值\n                {\"id\": \"not_a_number\"},  # 类型错误\n            ]\n        \n        @staticmethod\n        def generate_edge_cases() -> List[Dict[str, Any]]:\n            \"\"\"生成边界情况数据\"\"\"\n            return [\n                {\"id\": 0, \"name\": \"a\"},  # 最小值\n                {\"id\": 2**31-1, \"name\": \"x\"*255},  # 最大值\n                {\"id\": 1, \"name\": \"test\", \"extra\": \"field\"},  # 额外字段\n            ]\n    \n    return TestDataGenerator()\n\n\n# 断言辅助工具\n@pytest.fixture\ndef assertion_helpers():\n    \"\"\"断言辅助工具\"\"\"\n    class AssertionHelpers:\n        @staticmethod\n        def assert_contract_compliance(result, expected_type, required_fields=None):\n            \"\"\"断言结果符合契约\"\"\"\n            assert isinstance(result, expected_type), f\"Expected {expected_type}, got {type(result)}\"\n            \n            if required_fields:\n                for field in required_fields:\n                    assert hasattr(result, field) or field in result, f\"Missing required field: {field}\"\n        \n        @staticmethod\n        def assert_error_with_message(func, expected_error, expected_message_part, *args, **kwargs):\n            \"\"\"断言函数抛出包含特定消息的异常\"\"\"\n            with pytest.raises(expected_error) as exc_info:\n                func(*args, **kwargs)\n            \n            assert expected_message_part in str(exc_info.value), \\\n                f\"Expected error message to contain '{expected_message_part}', got '{str(exc_info.value)}'\"\n        \n        @staticmethod\n        def assert_performance(func, max_time, *args, **kwargs):\n            \"\"\"断言函数执行性能\"\"\"\n            import time\n            start = time.time()\n            result = func(*args, **kwargs)\n            duration = time.time() - start\n            \n            assert duration <= max_time, f\"Function took {duration:.3f}s, expected <= {max_time}s\"\n            return result\n    \n    return AssertionHelpers()\n\n\n# 清理和资源管理\n@pytest.fixture(autouse=True)\ndef cleanup_resources():\n    \"\"\"自动清理资源\"\"\"\n    # 测试前准备\n    yield\n    # 测试后清理\n    # 这里可以添加通用的清理逻辑\n\n\n# 参数化测试辅助\n@pytest.fixture\ndef parametrize_helper():\n    \"\"\"参数化测试辅助工具\"\"\"\n    def create_test_cases(test_data_dict):\n        \"\"\"从测试数据字典创建参数化测试用例\"\"\"\n        return pytest.mark.parametrize(\n            \"test_input,expected\", \n            list(test_data_dict.items())\n        )\n    \n    return create_test_cases\n\n\n# 契约测试专用的模拟工具\n@pytest.fixture\ndef contract_mocks():\n    \"\"\"契约测试专用的模拟对象\"\"\"\n    class ContractMocks:\n        def __init__(self):\n            self.external_service = Mock()\n            self.database = Mock() \n            self.cache = Mock()\n            self.logger = Mock()\n            \n        def setup_success_scenario(self):\n            \"\"\"设置成功场景的模拟\"\"\"\n            self.external_service.call.return_value = {\"status\": \"success\"}\n            self.database.query.return_value = [{\"id\": 1, \"name\": \"test\"}]\n            self.cache.get.return_value = None\n            \n        def setup_error_scenario(self):\n            \"\"\"设置错误场景的模拟\"\"\"\n            self.external_service.call.side_effect = ConnectionError(\"Network error\")\n            self.database.query.side_effect = Exception(\"Database error\")\n            \n        def verify_interactions(self):\n            \"\"\"验证模拟对象的交互\"\"\"\n            assert self.external_service.call.called\n            assert self.database.query.called\n    \n    return ContractMocks()"
    }
  ]
}